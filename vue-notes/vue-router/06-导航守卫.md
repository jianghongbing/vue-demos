# 导航守卫

在路由跳转的过程中, vue-router提供了一些钩子函数来处理路由的跳转, 在这个钩子函数中, 可以跳转, 取消或者重定向到其他路由, 这些钩子函数就是导航守卫. 在路由跳转过程中, 有三种方式来添加导航守卫, 分别为全局添加, 路由选项中添加, 组件中添加. 

## 全局导航守卫 

全局导航守卫是在router实例上添加的, 有三个方法, 分别如下: 

* beforeEach 前置守卫, 当一个导航触发, 路由还没有发生跳转时调用. 守卫是异步解析执行, 此时导航在所有守卫 resolve 完之前一直处于 等待中. 
* beforeResolve: 解析守卫. 是在导航被确认之前, 同时在所有组件内守卫和异步路由组件被解析之后, 解析守卫就被调用. 
* afterEach 后置守卫, 导航完成后调用

## 路由导航守卫

路由导航守卫是在route配置中添加的, 只有守卫方法beforeEnter, 在该跳转该路由之前会被触发, 该守卫是路由独享的, 不会涉及到其他路由. 

## 组件内的导航守卫 

组件内的导航守卫是直接添加在组件选项中的,  有以下三个导航守卫方法. 

* beforeRouteEnter, 在渲染该组件的对应路由被确定前调用, 由于在此时组件实例还没有被创建, 因此在该方法中, 不能使用this来获取当前组件实例. 
* befromRouteUpdate: 在当前路由改变, 该组件被复用时调用. 
* beforeRouteLeave: 在离开该路由之前调用. 

### 导航守卫钩子函数参数

上面所说的钩子函数都接收一个回调函数作为它的参数, 回调函数基本都接收相同的几个参数, 参数说明如下: 

* to: 将要跳转的路由
* from: 将要离开的路由
* next: 一个函数, 如果回调函数中, 有该参数, 确保next函数在任何给定的导航守卫中都被严格调用一次, 它可以出现多于一次, 但是只能在所有的逻辑路径都不重叠的情况下, 否则钩子永远都不会被解析或报错. 路由导航的执行效果依赖于next函数的参数. 
  * next(): 直接调用next函数, 表示执行下一个钩子, 如果全部钩子函数执行完了, 则导航的状态就是确认的
  * next(false): 如果next函数参数为false, 表示中断当前的导航. 如果浏览器的 URL 改变了 (可能是用户手动或者浏览器后退按钮), 那么 URL 地址会重置到 from 路由对应的地址. 
  * next(其他路由路径或者对象): 跳转到其他的路由. 当前的导航会被中断, 然后进行一个新的导航. 可以向 next 传递任意位置对象, 且允许设置诸如 replace: true、name: 'home' 之类的选项以及任何用在 router-link 的 to prop 或 router.push 中的选项. 
  * next(error): 如果传入next的参数是一个 Error 实例, 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调. 

## 完整的导航解析流程

1. 导航被触发
2. 在失活的组件里调用 beforeRouteLeave 守卫
3. 调用全局的 beforeEach 守卫
4. 在重用的组件里调用 beforeRouteUpdate 守卫
5. 在路由配置里调用 beforeEnter
6. 解析异步路由组件
7. 在被激活的组件里调用 beforeRouteEnter
8. 调用全局的 beforeResolve 守卫 
9. 导航被确认
10. 调用全局的 afterEach 钩子
11. 触发 DOM 更新
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数, 创建好的组件实例会作为回调函数的参数传入